---
title: "run_model_20240817"
output: html_document
date: "2024-08-17"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Script source & function

Adapted for full model run from TEST_run_models script.

Use model_specification.txt file [update with most recent model spec] which contains the script for the model itself.

This R script implements a Bayesian hierarchical model to analyze cormorant colony dynamics across multiple peninsulas from 1992 to 2023. It uses data on nest density, road proximity, black-crowned night heron nest success, double-crested cormorant usurpation, and management practices to predict a growth index for cormorant colonies. The script employs the R2jags package to fit the model, which allows for the incorporation of both fixed effects (environmental and management factors) and random effects (year-to-year variability).

The script begins by loading and preparing the data, then sets up the JAGS model with appropriate initial values and prior distributions for the parameters. It runs the model using Markov Chain Monte Carlo (MCMC) sampling with multiple chains, and includes a burn-in period and thinning to ensure efficient and reliable posterior estimates. After fitting the model, the script generates various diagnostic plots and summary statistics, providing insights into the factors influencing cormorant colony growth over time and across different locations. The results are then saved for further analysis and interpretation.

## Load libraries and resolve conflicts
```{r}
library(tidyverse)
library(R2jags)

conflicts_prefer(dplyr::filter)

```

## Load data and prep data 
```{r}
# Load the data
model_data <- read_csv("C:/Users/baill/OneDrive/r-projects/cormorant-colony-analysis/current working files/model datasets/combined_model_data.csv")

# Rename columns to match JAGS model
model_data <- model_data %>%
  rename(
    nest_density = density,
    road_proximity = proximity,
    bcnh_nest_success = success,
    dcco_usurpation = usurpation,
    dcco_management = management
  )

#calculate number of observations (N) and unique years (N_years)
N <- nrow(model_data)
year <- as.numeric(factor(model_data$year))
N_years <- length(unique(year))
print(paste("Number of observations:", N))
print(paste("Number of years:", N_years))

```

## Prepare data for JAGS
Creates a list (jags_data) containing all the variables needed for the JAGS model (takes combined_data and selects appropriate column for each predictor variable).

Prints the structure and first few rows of each variable for debugging purposes. Print steps just shows current data as loaded to look for inconsistencies or errors that need to be fixed in the dataset itself.
```{r}

# Prepare data for JAGS
jags_data <- list(
  N = N,
  y = model_data$growth_index,
  nest_density = model_data$nest_density,
  road_proximity = model_data$road_proximity,
  bcnh_nest_success = model_data$bcnh_nest_success,
  dcco_usurpation = model_data$dcco_usurpation,
  dcco_management = model_data$dcco_management,
  N_years = N_years,
  year = year
)

# Print structure of jags_data for debugging
print("Structure of jags_data:")
print(str(jags_data))

# Print first few rows of each variable
print("First few rows of each variable:")
for (var in names(jags_data)) {
  if (is.vector(jags_data[[var]])) {
    print(paste(var, ":", paste(head(jags_data[[var]]), collapse = ", ")))
  }
}

```

## Model initialization
Defines an initialization function (inits) that generates random initial values for the model parameters.
Specifies which parameters to monitor during the MCMC sampling. The MCMC process will usually converge to the correct posterior distribution regardless of the starting points, as long as they're not extremely unreasonable. However, good initial values can help the model converge faster.

beta= vector of regression coefficients for fixed effects in the model. Represents the fixed effects of the various predictors on the response variable (growth index).The MCMC process samples from the posterior distribution of these coefficients, which combines the likelihood of the data given the parameters and the prior distribution specified for beta.The final estimate is typically the mean or median of these posterior samples.
rnorm(6,0,1)= generates 6 random numbers from a normal distribution with mean 0 and standard deviation 1.
  6 numbers correspond to effects of nest_density, road_proximity, bcnh_nest_success, dcco_usurpation, dcco_management, and intercept (number of predictors + 1 for intercept)

sigma= overall residual standard deviation of the response variable (growth index)- variability or uncertainty in the response variable that is not explained by the predictors.Residuals are the differences between the observed values of the response variable (growth_index) and the values predicted by the model. Sigma quantifies how much the actual growth_index values typically deviate from the model's predictions.
runif(1,0,10)= generates 1 random number from a uniform distribution between 0 & 10. Bounds chosen to encompass reasonable values for standard deviations. May need to adjust bounds for smaller range of growth index eg (1,0,1)

sigma_year= standard deviation for response variable. initialized with random value between 0 & 10

alpha_year= random year effects. They're estimated as deviations from the overall fixed effects, capturing year-to-year variability not explained by the fixed predictors. rnorm(N_years,0,1) generates N_years random numbers from a normal distribution with mean 0 and standard deviation1. May need to adjust based on expected year to year variability- if expecting large year effects, may need to use(N_years, 0,5) or higher.

N_years= number of unique years in dataset

The model assumes these effects come from a normal distribution with mean 0 and standard deviation sigma_year.
The MCMC process samples from the posterior distribution of each year's effect.

This function gets called for each MCMC chain to provide different random starting values for each chain- the chain will explore different parts of the parameter space and can be used to assess convergence of the MCMC algorithm.

parameters vector= specifies which parameters the model should track and return results for. Parameters vector tells the model to save MCMC samples for these parameters, to examine posterior distributions.

#Strategy for inits
Start with these default values.
Run the model and check convergence diagnostics.
If convergence is slow or fails, adjust the initial values based on preliminary results or domain knowledge.
Eg if sigma is estimated to be around 0.5 or higher by the model, can adjust bounds of sigma in subsequent runs. (sigma = runif(1, 0, 2),)
```{r}

# Initial values function
inits <- function() {
  list(
    beta = rnorm(6, 0, 1),
    sigma = runif(1, 0, 10),
    sigma_year = runif(1, 0, 10),
    alpha_year = rnorm(N_years, 0, 1)
  )
}

# Parameters to monitor
parameters <- c("beta", "sigma", "sigma_year", "alpha_year")
```

## Fit model & run the model with R2JAGS
Model Fitting:
Uses the jags() function to fit the Bayesian model.
Specifies the data, initial values, parameters to save, model file, and MCMC settings (chains, iterations, burn-in, thinning).

n.chains= specifies number of MCMC chains to run. Increase n.chains if want more assurance of convergence or if seeing discrepancies between chains.

n.iter= number of iterations each chain will run, including burn in and sampling period. Increase n.iter if you need more precise estimates or if the model is not converging. 50,000 is often sufficient, more complex models might require more.

n.burnin= number of initial iterations to discard from each chain. Allows chains to converge to target distribution before collecting samples. Increase n.burnin if convergence diagnostics suggest the chains haven't reached the target distribution by the end of the current burn-in period. 2000 is often enough, may need to increase for complex models or if convergence diagnostics suggest issues.

n.thin= thinning interval, keeping every 10th sample and discarding the rest. Increase n.thin if seeing high autocorrelation in samples or if you need to save memory. Decrease it if need more samples.

#strategy for fit
start with these values, run the model, check convergence diagnostics (like trace plots and the Gelman-Rubin statistic), and then adjust if necessary.
```{r}
fit <- jags(
  data = jags_data,
  inits = inits,
  parameters.to.save = parameters,
  model.file = "C:/Users/baill/OneDrive/r-projects/cormorant-colony-analysis/current working files/winbugs model scripts/test_models/comprehensive_model.txt",
  n.chains = 3,
  n.iter = 50000,
  n.burnin = 2000,
  n.thin = 10
)
```

## Results analysis & visualization
Prints and plots the model results.
Creates diagnostic plots (traceplots and density plots).
Extracts posterior samples and calculates summary statistics (mean and 95% credible intervals).
```{r}
# Print results
print(fit)

# Plot diagnostics
plot(fit)

# Get summary of the posterior distributions
fit_mcmc <- as.mcmc(fit)
summary(fit_mcmc)

# Save results
saveRDS(fit, "jags_comprehensive_model_results.rds")

# Create diagnostic plots
traceplot(fit)
densplot(fit)

# Extract posterior samples
posterior_samples <- as.matrix(fit_mcmc)

# Calculate mean and 95% credible intervals
results <- data.frame(
  parameter = colnames(posterior_samples),
  mean = colMeans(posterior_samples),
  lower_ci = apply(posterior_samples, 2, quantile, probs = 0.025),
  upper_ci = apply(posterior_samples, 2, quantile, probs = 0.975)
)

# Print results table
print(results)
```

## Save results
Saves the full model results as an RDS file.
Saves a summary table of the results as a CSV file.
```{r}
# Save results table
write.csv(results, "jags_comprehensive_model_results_table.csv", row.names = FALSE)
```
